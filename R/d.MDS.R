# d.MDS.R
# ::rtemis::
# 2018 Efstathios D. Gennatas egenn.github.io

#' Multidimensional Scaling
#'
#' Perform MDS decomposition using `stats:cmdscale`
#'
#' Project scaled variables to MDS components.
#' Input must be n by p,
#' where n represents number of cases,
#' and p represents number of features.
#' fastMDS will be applied to the transpose of the n x p matrix.
#' fastMDS will fail if there are any NA values or constant features: remove them using [preprocess]
#'
#' @inheritParams d.SVD
#' @param x Input data
#' @param k Integer vector of length 1 or greater. Rank of decomposition
#' @param dist.method String: method to use to calculate distance. See `stats::dist("method")`
#' @param eig Logical: If TRUE, return eigenvalues. Default = FALSE
#' @param add Logical: If TRUE, an additive constant `c*` will be computed and added to the
#' non-diagonal dissimilarities, which makes the Euclidean. Default = FALSE
#' @param x.ret Logical: If TRUE, return the doubly centered symmetric distance matrix. Default = FALSE
#' @param scale Logicall: If TRUE, scale input data before decomposition. Default = TRUE
#' @param center Logicall: If TRUE, also center input data if `scale` is `TRUE`.
#' Default = TRUE
#' @return [rtDecom] object
#' @author Efstathios D. Gennatas
#' @family Decomposition
#' @export

d.MDS <- function(x,
                  k = 2,
                  dist.method = c("euclidean", "maximum", "manhattan",
                                  "canberra", "binary", "minkowski"),
                  eig = FALSE,
                  add = FALSE,
                  x.ret = FALSE,
                  scale = TRUE,
                  center = TRUE,
                  verbose = TRUE, ...) {

  # [ INTRO ] ====
  start.time <- intro(verbose = verbose)
  dist.method <- match.arg(dist.method)
  decom.name <- "MDS"

  # [ ARGUMENTS ] ====
  if (missing(x)) {
    print(args(d.MDS))
    stop("x is missing")
  }

  # [ DATA ] ====
  x <- as.data.frame(x)
  n <- NROW(x)
  p <- NCOL(x)
  if (verbose) {
    msg("||| Input has dimensions ", n, " rows by ", p, " columns,", sep = "")
    msg("    interpreted as", n, "cases with", p, "features.")
  }
  if (is.null(colnames(x))) colnames(x) <- paste0('Feature_', seq(NCOL(x)))
  xnames <- colnames(x)
  if (scale) {
    x <- scale(x, center = center)
  }

  # [ MDS ] ====
  if (verbose) msg("Running Multidimensional Scaling...")
  .dist <- dist(x, method = dist.method)
  decom <- cmdscale(.dist, k = k, eig = eig, add = add, x.ret = x.ret, list. = TRUE)

  # [ PROJECTIONS ] ====
  projections.train <- decom$points
  colnames(projections.train) <- paste0("MDS", seq(NCOL(projections.train)))

  # [ OUTRO ] ====
  extra <- list()
  rt <- rtDecom$new(decom.name = decom.name,
                    decom = decom,
                    xnames = xnames,
                    projections.train = projections.train,
                    projections.test = NULL,
                    parameters = list(k = k,
                                      dist.method = dist.method,
                                      eig = eig,
                                      add = add,
                                      x.ret = x.ret,
                                      scale = scale,
                                      center = center),
                    extra = extra)
  outro(start.time, verbose = verbose)
  rt

} # rtemis::d.MDS
